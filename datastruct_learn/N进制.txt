// 【分析】
// 【十进制 转 负二进制】
//  c++ ：
//      除法向零取整
//      余数与被除数符号相同
//      e.g:    19  = (-9) * (-2) +   1       （10111）
//             -19  =   9  * (-2) + (-1)     （111101）
//
//  权重： 10       9       8       7       6       5       4       3       2       1       0
//        1024    -512    256     -128     64     -32      16      -8      4       -2       1
//
//  由于不同语言 针对负数的除法 有当无法整除时向上和向下取整的区别，（不同语言对于正数的除法都是向下取整）
//  因此需分析 进制表示 及 除法、取余运算 的本质
//
// 【十进制转x进制】：--------------------------------------------------------------------------------
//  本质：
//      n = a * (x)^5 + b * (x)^4 + c * (x)^3 + d * (x)^2 + e * (x)^1 + f * (x)^0
//      求 n 的 x 进制表示，本质上就是得到这里的系数 abcdef
//  对于一个数字 n 的 x 进制的表达式 abcdef 来说，更本质的x进制求法应该为：
//      1.  得到最低位的值f；
//          a.  对于二/负二进制来说，判断奇偶性即可判断f是1还是0  （除了最低位以外，其余位的权重都是偶数）
//          b.  对于其它进制来说，
//                  i.  若x为正数，则 f = n % x；
//                  ii. 但若x为负数，则这里还是需要针对不同语言的除法特性去分析，可能需要在 n % x 的基础上再进行一些运算操作得到 f
//      2.  先让 n -= f， 再让 n /= x ：
//          实际上是 先将n的最低位抹为0，之后再向右移一位， 最后 n = abcde（x进制表示）
//          （n -= f 是为了使得之后的 n /= x 是整除，避开不同语言在无法整除时存在向上向下取整的区别）
//  （由于该方法在进行 /= 运算时已经保证了是整除，因此对于任何语言都适用）
//---------------------------------------------------------------------------

class Solution
{
public:
    string baseNeg2(int n)
    {
        if (n == 0)
            return "0";

        string ans;
        while (n != 0)
        {
            // 获取当前最低位f
            if (n % -2 == 0) // 当前n为偶数，当前n的最低位为0，后续直接抹去这个最低位，除以-2即可
                ans += "0";
            else // 当前n为奇数，当前n的最低位f为1 （tips：虽然 n % -2 可能为1或-1，但不影响，都是最低位f=1）
            {
                n -= 1; // 将最低位的值抹去后，使得n变为偶数，在进行除负二操作时是整除
                ans += "1";
            }

            // 将n的负二进制表达式向右移一位
            n /= -2;
        }
        reverse(ans.begin(), ans.end()); // 除法和取余运算得到的是从低位到高位的结果，故最后要翻转
        return ans;
    }
};

作者：Yvette
链接：https://leetcode.cn/problems/convert-to-base-2/solutions/2211859/jin-zhi-biao-da-shi-de-ben-zhi-bu-tong-y-1x4a/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

// 【负三进制】
// 对于负三进制表达式来说，每位的可能取值为0 1 2，因此只有为0 1 2的余数是有效的，即我们要找的当前最低位f应是这些有效余数
// 但由于语言特性，n % -3 的可能结果是-2 -1 0 1 2，其中的-2和-1不是我们需要的余数，因此需要进行转换，给他们都加一个 base 使余数落在 [0,base-1] 的区间上
// 之后对于得到的这个有效余数去进行后续常规操作即可

// 说明为什么给 r 加个 base 不影响结果（或者说是正确的）：
//   n = a * base + r
//     = (a - 1) * base + (r + base)
//   1.  从前面系数中挪一个 base 给 r 并不影响该等式的成立
//   2.  我们要找的就是满足 n = …… + a * (base)^5 + b * (base)^4 + c * (base)^3 + d * (base)^2 + e * (base)^1 + f * (base)^0 的各项有效系数（即过程中的余数）
//       在循环的每一步都需要确定一个有效系数，并在这个系数的基础上继续找后续的系数

string baseNeg3(int n)
{
    if (n == 0)
        return "0";

    string ans;
    while (n != 0)
    {
        // 获取当前最低位f
        // n % -3 的可能取值为 -2 -1 0 1 2
        int r = n % -3;
        if (r == 0) // 当前最低位本身就为0，后续直接抹去这个最低位，除以-3即可
            ans += "0";
        else if (r < 0) // -2 -1
        {
            r += 3; // 要将余数转换为有效的范围，正数的余数才是我们要找的那个余数，作为f
            n -= r; // 将最低位的值f抹去，保证后续 n /= -3 是整除，从而保证不同语言的通用性
            ans += '0' + r;
        }
        else // r > 0
        {
            n -= r;
            ans += '0' + r;
        }

        // 将n的进制表达式向右移一位
        n /= -3;
    }
    reverse(ans.begin(), ans.end()); // 除法和取余运算得到的是从低位到高位的结果，故最后要翻转
    return ans;
}

作者：Yvette
链接：https://leetcode.cn/problems/convert-to-base-2/solutions/2211859/jin-zhi-biao-da-shi-de-ben-zhi-bu-tong-y-1x4a/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

// 【分析】
//  n = …… + a * (base)^5 + b * (base)^4 + c * (base)^3 + d * (base)^2 + e * (base)^1 + f * (base)^0
//  若base为正数，则n也必定为非负数
//  若base为负数，则n可为所有整数

// 【任意base的通用写法】
string baseAny(int n, int base)
{
    if (n == 0)
        return "0";

    string ans;
    while (n != 0)
    {
        // 获取当前最低位
        int r = n % base;
        if (r < 0)     // 说明 base 必为负数
            r -= base; // 保证找到的余数在有效范围 [0, base - 1] 内
        n -= r;        // 将最后一位抹零，保证后续是整除，从而保证不同语言通用
        if (r >= 10)
            ans += 'A' + r - 10;
        else
            ans += '0' + r;

        // 将n的进制表达式向右移一位
        n /= base;
    }
    reverse(ans.begin(), ans.end());
    return ans;
}

作者：Yvette
链接：https://leetcode.cn/problems/convert-to-base-2/solutions/2211859/jin-zhi-biao-da-shi-de-ben-zhi-bu-tong-y-1x4a/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。